import { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport readline from 'readline';\nimport chalk from 'chalk';\nimport figlet from 'figlet';\nimport boxen from 'boxen';\nimport ora from 'ora';\nimport { spawn } from 'child_process';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { performance } from 'perf_hooks';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n/**\n * Terminal MCP Client for Debo\n * \n * PURPOSE:\n * Provides a standalone terminal interface for interacting with the Debo MCP server,\n * similar to Claude Code but using local LLMs with better memory management.\n * \n * FEATURES:\n * - Direct MCP server communication\n * - Interactive chat interface\n * - Real-time development feedback\n * - Session management\n * - Command history\n * - File watching and live updates\n * \n * TODO:\n * - None\n */\nexport class TerminalMCPClient {\n  constructor() {\n    this.client = null;\n    this.transport = null;\n    this.connected = false;\n    this.sessionId = `session_${Date.now()}`;\n    this.conversationHistory = [];\n    this.currentProject = null;\n    \n    // Setup readline interface\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      prompt: chalk.cyan('debo> ')\n    });\n    \n    this.setupReadline();\n  }\n  \n  setupReadline() {\n    // Enable command history\n    this.rl.on('line', (input) => {\n      this.handleInput(input.trim());\n    });\n    \n    // Handle Ctrl+C gracefully\n    this.rl.on('SIGINT', () => {\n      this.handleExit();\n    });\n    \n    // Setup command completion\n    this.rl.on('SIGTSTP', () => {\n      // Handle Ctrl+Z if needed\n    });\n  }\n  \n  async start() {\n    await this.showWelcome();\n    await this.connectToMCP();\n    await this.startInteractiveSession();\n  }\n  \n  async showWelcome() {\n    console.clear();\n    \n    // ASCII art header\n    const header = figlet.textSync('DEBO', {\n      font: 'ANSI Shadow',\n      horizontalLayout: 'default'\n    });\n    \n    console.log(chalk.cyan(header));\n    console.log(chalk.gray('â”'.repeat(80)));\n    console.log(chalk.yellow.bold('ðŸ¤– Autonomous Development Terminal'));\n    console.log(chalk.gray('Local LLMs â€¢ Better Memory â€¢ Faster Development'));\n    console.log(chalk.gray('â”'.repeat(80)));\n    console.log('');\n    \n    // Show system info\n    const infoBox = boxen(\n      `Session ID: ${chalk.cyan(this.sessionId)}\\n` +\n      `Working Directory: ${chalk.yellow(process.cwd())}\\n` +\n      `Node.js: ${chalk.green(process.version)}\\n` +\n      `Memory: ${chalk.blue((process.memoryUsage().heapUsed / 1024 / 1024).toFixed(1))}MB`,\n      {\n        title: 'System Info',\n        padding: 1,\n        borderColor: 'gray'\n      }\n    );\n    \n    console.log(infoBox);\n    console.log('');\n  }\n  \n  async connectToMCP() {\n    const spinner = ora('Connecting to Debo MCP server...').start();\n    \n    try {\n      // Start the MCP server as a subprocess\n      const serverPath = path.join(__dirname, 'mcp_server_v2.js');\n      const serverProcess = spawn('node', [serverPath], {\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n      \n      // Create transport\n      this.transport = new StdioClientTransport({\n        stdin: serverProcess.stdin,\n        stdout: serverProcess.stdout\n      });\n      \n      // Create client\n      this.client = new Client({\n        name: 'debo-terminal-client',\n        version: '2.0.0'\n      }, {\n        capabilities: {\n          tools: {},\n          sampling: {}\n        }\n      });\n      \n      // Connect\n      await this.client.connect(this.transport);\n      \n      this.connected = true;\n      spinner.succeed('Connected to Debo MCP server');\n      \n      // Get available tools\n      const tools = await this.client.listTools();\n      console.log(chalk.green(`\\nâœ… ${tools.tools.length} tools available`));\n      \n      // Check if we're in a project directory\n      await this.detectProject();\n      \n    } catch (error) {\n      spinner.fail('Failed to connect to MCP server');\n      console.error(chalk.red(`Error: ${error.message}`));\n      process.exit(1);\n    }\n  }\n  \n  async detectProject() {\n    try {\n      // Check for common project indicators\n      const fs = await import('fs-extra');\n      const cwd = process.cwd();\n      \n      const projectIndicators = [\n        'package.json',\n        'requirements.txt',\n        'Cargo.toml',\n        'pom.xml',\n        'build.gradle',\n        '.git'\n      ];\n      \n      for (const indicator of projectIndicators) {\n        if (await fs.pathExists(path.join(cwd, indicator))) {\n          this.currentProject = {\n            path: cwd,\n            name: path.basename(cwd),\n            type: this.getProjectType(indicator)\n          };\n          break;\n        }\n      }\n      \n      if (this.currentProject) {\n        console.log(chalk.green(`\\nðŸ“‚ Project detected: ${this.currentProject.name} (${this.currentProject.type})`));\n        \n        const shouldAnalyze = await this.askYesNo(\n          'Would you like me to analyze this existing codebase?'\n        );\n        \n        if (shouldAnalyze) {\n          await this.analyzeExistingProject();\n        }\n      } else {\n        console.log(chalk.yellow('\\nðŸ“ No project detected in current directory'));\n        console.log(chalk.gray('You can still create new projects or navigate to an existing one'));\n      }\n      \n    } catch (error) {\n      console.warn(chalk.yellow(`Warning: Could not detect project: ${error.message}`));\n    }\n  }\n  \n  getProjectType(indicator) {\n    const types = {\n      'package.json': 'Node.js',\n      'requirements.txt': 'Python',\n      'Cargo.toml': 'Rust',\n      'pom.xml': 'Maven/Java',\n      'build.gradle': 'Gradle/Java',\n      '.git': 'Git Repository'\n    };\n    \n    return types[indicator] || 'Unknown';\n  }\n  \n  async analyzeExistingProject() {\n    console.log(chalk.cyan('\\nðŸ” Analyzing existing codebase...'));\n    \n    try {\n      // Use the debo tool to analyze the project\n      const response = await this.client.callTool({\n        name: 'debo',\n        arguments: {\n          request: `Analyze the existing codebase at ${this.currentProject.path}. Provide a comprehensive analysis including:\n          - File structure and organization\n          - Technology stack and frameworks\n          - Dependencies and their relationships\n          - Code quality metrics\n          - Potential improvements\n          - Architecture patterns\n          - Documentation status\n          \n          Then suggest specific tasks for improvement and ask me about my goals for this project.`\n        }\n      });\n      \n      if (response.content) {\n        this.displayResponse(response.content[0].text);\n        this.addToHistory('system', 'Codebase analysis completed');\n      }\n      \n    } catch (error) {\n      console.error(chalk.red(`Analysis failed: ${error.message}`));\n    }\n  }\n  \n  async startInteractiveSession() {\n    console.log(chalk.green('\\nðŸš€ Debo is ready! Type your requests or commands.'));\n    console.log(chalk.gray('Commands: /help, /status, /history, /clear, /exit'));\n    console.log('');\n    \n    this.rl.prompt();\n  }\n  \n  async handleInput(input) {\n    if (!input) {\n      this.rl.prompt();\n      return;\n    }\n    \n    // Handle commands\n    if (input.startsWith('/')) {\n      await this.handleCommand(input);\n      this.rl.prompt();\n      return;\n    }\n    \n    // Regular request\n    await this.processRequest(input);\n    this.rl.prompt();\n  }\n  \n  async handleCommand(command) {\n    const [cmd, ...args] = command.split(' ');\n    \n    switch (cmd) {\n      case '/help':\n        this.showHelp();\n        break;\n        \n      case '/status':\n        await this.showStatus();\n        break;\n        \n      case '/history':\n        this.showHistory();\n        break;\n        \n      case '/clear':\n        console.clear();\n        await this.showWelcome();\n        break;\n        \n      case '/analyze':\n        if (this.currentProject) {\n          await this.analyzeExistingProject();\n        } else {\n          console.log(chalk.yellow('No project detected. Navigate to a project directory first.'));\n        }\n        break;\n        \n      case '/project':\n        await this.handleProjectCommand(args);\n        break;\n        \n      case '/session':\n        this.showSessionInfo();\n        break;\n        \n      case '/export':\n        await this.exportSession(args[0]);\n        break;\n        \n      case '/exit':\n      case '/quit':\n        await this.handleExit();\n        break;\n        \n      default:\n        console.log(chalk.red(`Unknown command: ${cmd}`));\n        console.log(chalk.gray('Type /help for available commands'));\n    }\n  }\n  \n  showHelp() {\n    const helpBox = boxen(\n      `${chalk.bold('Available Commands:')}\\n\\n` +\n      `${chalk.cyan('/help')}           - Show this help message\\n` +\n      `${chalk.cyan('/status')}         - Show system status\\n` +\n      `${chalk.cyan('/history')}        - Show conversation history\\n` +\n      `${chalk.cyan('/clear')}          - Clear screen and reset display\\n` +\n      `${chalk.cyan('/analyze')}        - Analyze current project codebase\\n` +\n      `${chalk.cyan('/project [path]')} - Switch to different project\\n` +\n      `${chalk.cyan('/session')}        - Show session information\\n` +\n      `${chalk.cyan('/export [file]')}  - Export conversation to file\\n` +\n      `${chalk.cyan('/exit')}           - Exit Debo terminal\\n\\n` +\n      `${chalk.bold('Example Requests:')}\\n\\n` +\n      `â€¢ \"Add user authentication to my app\"\\n` +\n      `â€¢ \"Improve the performance of my React components\"\\n` +\n      `â€¢ \"Create unit tests for the user service\"\\n` +\n      `â€¢ \"Setup CI/CD pipeline with GitHub Actions\"\\n` +\n      `â€¢ \"Refactor the database layer to use TypeORM\"`,\n      {\n        title: chalk.bold('ðŸ¤– Debo Help'),\n        padding: 1,\n        borderColor: 'cyan',\n        borderStyle: 'round'\n      }\n    );\n    \n    console.log('\\n' + helpBox);\n  }\n  \n  async showStatus() {\n    const startTime = performance.now();\n    \n    try {\n      // Check MCP connection\n      const tools = await this.client.listTools();\n      const connectionTime = performance.now() - startTime;\n      \n      const statusBox = boxen(\n        `${chalk.bold('Connection Status:')}\\n` +\n        `MCP Server: ${chalk.green('Connected')}\\n` +\n        `Response Time: ${chalk.cyan(connectionTime.toFixed(1) + 'ms')}\\n` +\n        `Available Tools: ${chalk.blue(tools.tools.length)}\\n\\n` +\n        `${chalk.bold('Session Status:')}\\n` +\n        `Session ID: ${chalk.yellow(this.sessionId)}\\n` +\n        `Messages: ${chalk.cyan(this.conversationHistory.length)}\\n` +\n        `Current Project: ${chalk.magenta(this.currentProject?.name || 'None')}\\n\\n` +\n        `${chalk.bold('System Status:')}\\n` +\n        `Memory Usage: ${chalk.green((process.memoryUsage().heapUsed / 1024 / 1024).toFixed(1) + 'MB')}\\n` +\n        `Uptime: ${chalk.blue(process.uptime().toFixed(0) + 's')}`,\n        {\n          title: chalk.bold('ðŸ“Š System Status'),\n          padding: 1,\n          borderColor: 'green'\n        }\n      );\n      \n      console.log('\\n' + statusBox);\n      \n    } catch (error) {\n      console.error(chalk.red(`Status check failed: ${error.message}`));\n    }\n  }\n  \n  showHistory() {\n    if (this.conversationHistory.length === 0) {\n      console.log(chalk.yellow('No conversation history yet.'));\n      return;\n    }\n    \n    console.log(chalk.cyan('\\nðŸ“š Conversation History:'));\n    console.log(chalk.gray('â”'.repeat(50)));\n    \n    this.conversationHistory.slice(-10).forEach((entry, index) => {\n      const timestamp = new Date(entry.timestamp).toLocaleTimeString();\n      const role = entry.role === 'user' ? chalk.blue('You') : chalk.green('Debo');\n      const preview = entry.content.length > 100 ? \n        entry.content.substring(0, 100) + '...' : \n        entry.content;\n      \n      console.log(`${chalk.gray(timestamp)} ${role}: ${preview}`);\n    });\n    \n    if (this.conversationHistory.length > 10) {\n      console.log(chalk.gray(`... and ${this.conversationHistory.length - 10} more messages`));\n    }\n  }\n  \n  async handleProjectCommand(args) {\n    if (args.length === 0) {\n      if (this.currentProject) {\n        console.log(chalk.green(`Current project: ${this.currentProject.name}`));\n        console.log(chalk.gray(`Path: ${this.currentProject.path}`));\n        console.log(chalk.gray(`Type: ${this.currentProject.type}`));\n      } else {\n        console.log(chalk.yellow('No current project set'));\n      }\n      return;\n    }\n    \n    const projectPath = args[0];\n    \n    try {\n      const fs = await import('fs-extra');\n      const fullPath = path.resolve(projectPath);\n      \n      if (await fs.pathExists(fullPath)) {\n        process.chdir(fullPath);\n        await this.detectProject();\n        console.log(chalk.green(`Switched to project: ${fullPath}`));\n      } else {\n        console.log(chalk.red(`Project path does not exist: ${projectPath}`));\n      }\n    } catch (error) {\n      console.error(chalk.red(`Failed to switch project: ${error.message}`));\n    }\n  }\n  \n  showSessionInfo() {\n    const sessionBox = boxen(\n      `${chalk.bold('Session Information:')}\\n\\n` +\n      `ID: ${chalk.cyan(this.sessionId)}\\n` +\n      `Started: ${chalk.yellow(new Date().toLocaleString())}\\n` +\n      `Messages: ${chalk.green(this.conversationHistory.length)}\\n` +\n      `Current Directory: ${chalk.blue(process.cwd())}\\n` +\n      `Project: ${chalk.magenta(this.currentProject?.name || 'None')}`,\n      {\n        title: chalk.bold('ðŸ“‹ Session Info'),\n        padding: 1,\n        borderColor: 'blue'\n      }\n    );\n    \n    console.log('\\n' + sessionBox);\n  }\n  \n  async exportSession(filename) {\n    const fs = await import('fs-extra');\n    const exportFile = filename || `debo-session-${this.sessionId}.json`;\n    \n    const sessionData = {\n      sessionId: this.sessionId,\n      timestamp: new Date().toISOString(),\n      project: this.currentProject,\n      history: this.conversationHistory,\n      workingDirectory: process.cwd()\n    };\n    \n    try {\n      await fs.writeJson(exportFile, sessionData, { spaces: 2 });\n      console.log(chalk.green(`Session exported to: ${exportFile}`));\n    } catch (error) {\n      console.error(chalk.red(`Export failed: ${error.message}`));\n    }\n  }\n  \n  async processRequest(request) {\n    const startTime = performance.now();\n    \n    // Add to history\n    this.addToHistory('user', request);\n    \n    // Show thinking indicator\n    const spinner = ora('Processing request...').start();\n    \n    try {\n      // Enhanced request with context\n      const contextualRequest = this.buildContextualRequest(request);\n      \n      // Call the debo tool\n      const response = await this.client.callTool({\n        name: 'debo',\n        arguments: {\n          request: contextualRequest\n        }\n      });\n      \n      const responseTime = performance.now() - startTime;\n      spinner.succeed(`Response generated in ${responseTime.toFixed(0)}ms`);\n      \n      if (response.content && response.content.length > 0) {\n        const responseText = response.content[0].text;\n        this.displayResponse(responseText);\n        this.addToHistory('assistant', responseText);\n      } else {\n        console.log(chalk.yellow('No response received'));\n      }\n      \n    } catch (error) {\n      spinner.fail('Request failed');\n      console.error(chalk.red(`Error: ${error.message}`));\n      \n      // Add error to history\n      this.addToHistory('system', `Error: ${error.message}`);\n    }\n  }\n  \n  buildContextualRequest(request) {\n    let contextualRequest = request;\n    \n    // Add project context if available\n    if (this.currentProject) {\n      contextualRequest = `Project Context:\n` +\n        `- Name: ${this.currentProject.name}\n` +\n        `- Type: ${this.currentProject.type}\n` +\n        `- Path: ${this.currentProject.path}\n\n` +\n        `Request: ${request}`;\n    }\n    \n    // Add recent conversation context\n    if (this.conversationHistory.length > 0) {\n      const recentHistory = this.conversationHistory.slice(-3)\n        .map(entry => `${entry.role}: ${entry.content.substring(0, 200)}`)\n        .join('\\n');\n      \n      contextualRequest += `\\n\\nRecent Conversation:\\n${recentHistory}`;\n    }\n    \n    return contextualRequest;\n  }\n  \n  displayResponse(responseText) {\n    console.log('\\n' + chalk.green('ðŸ¤– Debo:'));\n    console.log(chalk.gray('â”'.repeat(50)));\n    \n    // Parse and format the response\n    const formattedResponse = this.formatResponse(responseText);\n    console.log(formattedResponse);\n    \n    console.log(chalk.gray('â”'.repeat(50)));\n  }\n  \n  formatResponse(text) {\n    // Handle code blocks\n    text = text.replace(/```(\\w+)?\\n([\\s\\S]*?)```/g, (match, lang, code) => {\n      const languageLabel = lang ? chalk.blue(`[${lang}]`) : '';\n      return `\\n${languageLabel}\\n${chalk.cyan(code)}\\n`;\n    });\n    \n    // Handle inline code\n    text = text.replace(/`([^`]+)`/g, (match, code) => {\n      return chalk.cyan(code);\n    });\n    \n    // Handle bold text\n    text = text.replace(/\\*\\*(.*?)\\*\\*/g, (match, content) => {\n      return chalk.bold(content);\n    });\n    \n    // Handle headers\n    text = text.replace(/^#{1,3}\\s+(.+)$/gm, (match, header) => {\n      return chalk.yellow.bold(header);\n    });\n    \n    // Handle bullet points\n    text = text.replace(/^[-*+]\\s+(.+)$/gm, (match, item) => {\n      return `  ${chalk.blue('â€¢')} ${item}`;\n    });\n    \n    return text;\n  }\n  \n  addToHistory(role, content) {\n    this.conversationHistory.push({\n      role,\n      content,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Keep history manageable\n    if (this.conversationHistory.length > 100) {\n      this.conversationHistory.shift();\n    }\n  }\n  \n  async askYesNo(question) {\n    return new Promise((resolve) => {\n      this.rl.question(chalk.cyan(`${question} (y/n): `), (answer) => {\n        resolve(answer.toLowerCase().startsWith('y'));\n      });\n    });\n  }\n  \n  async handleExit() {\n    console.log(chalk.yellow('\\nðŸ‘‹ Shutting down Debo terminal...'));\n    \n    try {\n      if (this.connected && this.client) {\n        await this.client.close();\n      }\n      \n      if (this.transport) {\n        await this.transport.close();\n      }\n    } catch (error) {\n      console.warn(chalk.gray(`Warning during shutdown: ${error.message}`));\n    }\n    \n    this.rl.close();\n    console.log(chalk.gray('Goodbye! ðŸ¤–'));\n    process.exit(0);\n  }\n}\n\n// Export for use as a module\nexport default TerminalMCPClient;\n\n// If run directly, start the client\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const client = new TerminalMCPClient();\n  client.start().catch(error => {\n    console.error(chalk.red('Failed to start terminal client:'), error);\n    process.exit(1);\n  });\n}\n