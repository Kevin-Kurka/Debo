import readline from 'readline';\nimport chalk from 'chalk';\nimport boxen from 'boxen';\nimport ora from 'ora';\nimport { CodebaseAnalyzer } from './analyzer.js';\nimport logger from '../logger.js';\n\n/**\n * Interactive Project Planner\n * \n * PURPOSE:\n * Provides interactive terminal interface for project analysis,\n * task planning, and goal definition after codebase indexing.\n * \n * FEATURES:\n * - Interactive codebase analysis review\n * - Task planning with user input\n * - Project completion criteria definition\n * - Agent assignment recommendations\n * - Timeline estimation\n * \n * TODO:\n * - None\n */\nexport class ProjectPlanner {\n  constructor(taskManager, terminal) {\n    this.taskManager = taskManager;\n    this.terminal = terminal;\n    this.analyzer = new CodebaseAnalyzer(taskManager);\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n    \n    this.currentProject = null;\n    this.plannedTasks = [];\n    this.completionCriteria = [];\n  }\n  \n  async analyzeAndPlan(projectPath) {\n    try {\n      // Step 1: Analyze codebase\n      await this.runCodebaseAnalysis(projectPath);\n      \n      // Step 2: Review analysis with user\n      await this.reviewAnalysisWithUser();\n      \n      // Step 3: Define project goals\n      await this.defineProjectGoals();\n      \n      // Step 4: Plan tasks interactively\n      await this.planTasksInteractively();\n      \n      // Step 5: Set completion criteria\n      await this.setCompletionCriteria();\n      \n      // Step 6: Generate project plan\n      const projectPlan = await this.generateFinalPlan();\n      \n      // Step 7: Store plan and start execution\n      await this.storePlanAndStart(projectPlan);\n      \n      return projectPlan;\n      \n    } catch (error) {\n      this.terminal.showError(error, 'Project planning failed');\n      throw error;\n    }\n  }\n  \n  async runCodebaseAnalysis(projectPath) {\n    const spinner = ora('Analyzing existing codebase...').start();\n    \n    try {\n      this.currentProject = await this.analyzer.analyzeProject(projectPath);\n      \n      spinner.succeed(`Codebase analysis completed in ${this.currentProject.analysisTime}ms`);\n      \n      // Show analysis summary\n      this.showAnalysisSummary();\n      \n    } catch (error) {\n      spinner.fail('Codebase analysis failed');\n      throw error;\n    }\n  }\n  \n  showAnalysisSummary() {\n    const project = this.currentProject;\n    \n    console.log('\\n' + chalk.cyan('📊 Codebase Analysis Summary'));\n    console.log(chalk.gray('━'.repeat(60)));\n    \n    // Basic metrics\n    const metricsBox = boxen(\n      `Project: ${chalk.yellow(project.name)}\\n` +\n      `Files: ${chalk.green(project.metadata.totalFiles.toLocaleString())}\\n` +\n      `Lines of Code: ${chalk.blue(project.metadata.totalLines.toLocaleString())}\\n` +\n      `Languages: ${chalk.magenta(project.metadata.languages.join(', '))}\\n` +\n      `Quality Score: ${this.getQualityColor(project.quality.score)}${project.quality.score}/100`,\n      {\n        title: 'Project Overview',\n        padding: 1,\n        borderColor: 'cyan'\n      }\n    );\n    \n    console.log(metricsBox);\n    \n    // Technology stack\n    if (project.techStack.frameworks.length > 0) {\n      const frameworksBox = boxen(\n        project.techStack.frameworks\n          .map(f => `${chalk.yellow(f.name)} ${chalk.gray(f.version || '')} (${f.type})`)\n          .join('\\n'),\n        {\n          title: 'Frameworks Detected',\n          padding: 1,\n          borderColor: 'green'\n        }\n      );\n      \n      console.log(frameworksBox);\n    }\n    \n    // Issues and suggestions\n    if (project.quality.issues.length > 0) {\n      const issuesBox = boxen(\n        project.quality.issues\n          .map(issue => `${this.getSeverityIcon(issue.severity)} ${issue.message}`)\n          .join('\\n'),\n        {\n          title: 'Issues Found',\n          padding: 1,\n          borderColor: 'red'\n        }\n      );\n      \n      console.log(issuesBox);\n    }\n    \n    console.log('');\n  }\n  \n  getQualityColor(score) {\n    if (score >= 80) return chalk.green;\n    if (score >= 60) return chalk.yellow;\n    return chalk.red;\n  }\n  \n  getSeverityIcon(severity) {\n    switch (severity) {\n      case 'high': return '🔴';\n      case 'medium': return '🟡';\n      case 'low': return '🟢';\n      default: return 'ℹ️';\n    }\n  }\n  \n  async reviewAnalysisWithUser() {\n    console.log(chalk.cyan('\\n🔍 Let\\'s review the analysis together...'));\n    \n    // Show detailed breakdown\n    await this.showDetailedBreakdown();\n    \n    // Ask if user wants to see more details\n    const wantsDetails = await this.askYesNo(\n      'Would you like to see detailed file breakdown and dependency analysis?'\n    );\n    \n    if (wantsDetails) {\n      await this.showDetailedAnalysis();\n    }\n    \n    // Ask about accuracy\n    const analysisAccurate = await this.askYesNo(\n      'Does this analysis accurately reflect your project?'\n    );\n    \n    if (!analysisAccurate) {\n      await this.correctAnalysis();\n    }\n  }\n  \n  async showDetailedBreakdown() {\n    const project = this.currentProject;\n    \n    // Architecture pattern\n    console.log(chalk.green('\\n🏗️  Architecture Pattern:'), chalk.yellow(project.patterns.architectureStyle));\n    \n    // File organization\n    console.log(chalk.green('📁 Organization:'), chalk.yellow(project.structure.organizationPattern));\n    \n    // Dependencies\n    const totalDeps = project.dependencies.direct.length + project.dependencies.dev.length;\n    console.log(chalk.green('📦 Dependencies:'), chalk.cyan(`${totalDeps} total`));\n    \n    // Git status\n    if (project.gitHistory.hasGit) {\n      console.log(chalk.green('📊 Git Activity:'), \n        chalk.cyan(`${project.gitHistory.activity.totalCommits} commits, `) +\n        chalk.cyan(`${project.gitHistory.contributors.length} contributors`)\n      );\n    }\n  }\n  \n  async showDetailedAnalysis() {\n    const project = this.currentProject;\n    \n    // Large files\n    if (project.patterns.complexity.largestFiles.length > 0) {\n      console.log(chalk.yellow('\\n📄 Largest Files:'));\n      project.patterns.complexity.largestFiles.slice(0, 5).forEach(file => {\n        console.log(`  ${chalk.gray(file.name)} - ${chalk.cyan(file.lines)} lines`);\n      });\n    }\n    \n    // Dependencies by type\n    console.log(chalk.yellow('\\n📦 Direct Dependencies:'));\n    project.dependencies.direct.slice(0, 10).forEach(dep => {\n      console.log(`  ${chalk.green(dep.name)} ${chalk.gray(dep.version)}`);\n    });\n    \n    // Recent commits\n    if (project.gitHistory.recentCommits.length > 0) {\n      console.log(chalk.yellow('\\n📝 Recent Commits:'));\n      project.gitHistory.recentCommits.slice(0, 5).forEach(commit => {\n        console.log(`  ${chalk.gray(commit.hash)} ${chalk.blue(commit.author)} - ${commit.message}`);\n      });\n    }\n  }\n  \n  async correctAnalysis() {\n    console.log(chalk.yellow('\\n🔧 Let\\'s correct the analysis...'));\n    \n    // Allow user to override certain findings\n    const corrections = {};\n    \n    // Architecture style\n    const newArchStyle = await this.askQuestion(\n      `Current architecture detected as \"${this.currentProject.patterns.architectureStyle}\". ` +\n      'What would you call it? (or press Enter to keep current)'\n    );\n    \n    if (newArchStyle.trim()) {\n      corrections.architectureStyle = newArchStyle.trim();\n    }\n    \n    // Main frameworks\n    if (this.currentProject.techStack.frameworks.length === 0) {\n      const frameworks = await this.askQuestion(\n        'No frameworks were detected. What frameworks/libraries does this project use? (comma-separated)'\n      );\n      \n      if (frameworks.trim()) {\n        corrections.frameworks = frameworks.split(',').map(f => ({ name: f.trim(), type: 'manual' }));\n      }\n    }\n    \n    // Apply corrections\n    if (Object.keys(corrections).length > 0) {\n      await this.applyCorrections(corrections);\n      console.log(chalk.green('✅ Analysis updated with your corrections'));\n    }\n  }\n  \n  async applyCorrections(corrections) {\n    if (corrections.architectureStyle) {\n      this.currentProject.patterns.architectureStyle = corrections.architectureStyle;\n    }\n    \n    if (corrections.frameworks) {\n      this.currentProject.techStack.frameworks.push(...corrections.frameworks);\n    }\n    \n    // Re-store the updated analysis\n    await this.analyzer.storeProjectIndex(this.currentProject);\n  }\n  \n  async defineProjectGoals() {\n    console.log(chalk.cyan('\\n🎯 Let\\'s define your project goals...'));\n    \n    const goals = [];\n    \n    // Primary goal\n    const primaryGoal = await this.askQuestion(\n      'What is the main goal for this project? (e.g., \"Add user authentication\", \"Improve performance\", \"Add new features\")'\n    );\n    \n    goals.push({ type: 'primary', description: primaryGoal, priority: 1 });\n    \n    // Secondary goals\n    const hasSecondary = await this.askYesNo('Do you have additional goals or improvements in mind?');\n    \n    if (hasSecondary) {\n      let addingGoals = true;\n      let priority = 2;\n      \n      while (addingGoals) {\n        const goal = await this.askQuestion(`Goal #${priority}:`);\n        if (goal.trim()) {\n          goals.push({ type: 'secondary', description: goal, priority });\n          priority++;\n        }\n        \n        addingGoals = await this.askYesNo('Add another goal?');\n      }\n    }\n    \n    // Timeline\n    const timeline = await this.askQuestion(\n      'What\\'s your desired timeline? (e.g., \"2 weeks\", \"1 month\", \"ASAP\")'\n    );\n    \n    this.currentProject.goals = {\n      list: goals,\n      timeline,\n      definedAt: new Date().toISOString()\n    };\n    \n    // Show summary\n    console.log(chalk.green('\\n✅ Project Goals Defined:'));\n    goals.forEach((goal, index) => {\n      console.log(`  ${index + 1}. ${chalk.yellow(goal.description)}`);\n    });\n    console.log(`\\n⏰ Timeline: ${chalk.cyan(timeline)}`);\n  }\n  \n  async planTasksInteractively() {\n    console.log(chalk.cyan('\\n📋 Now let\\'s break this down into specific tasks...'));\n    \n    // Suggest tasks based on analysis\n    const suggestedTasks = this.generateTaskSuggestions();\n    \n    console.log(chalk.yellow('\\n💡 Based on your codebase analysis, here are some suggested tasks:'));\n    \n    suggestedTasks.forEach((task, index) => {\n      console.log(`  ${index + 1}. ${chalk.cyan(task.title)} ${chalk.gray('(' + task.category + ')')}`);\n      console.log(`     ${chalk.gray(task.description)}`);\n    });\n    \n    // Let user review and modify\n    const useAllSuggestions = await this.askYesNo('\\nWould you like to include all suggested tasks?');\n    \n    if (useAllSuggestions) {\n      this.plannedTasks = [...suggestedTasks];\n    } else {\n      // Let user pick tasks\n      for (let i = 0; i < suggestedTasks.length; i++) {\n        const task = suggestedTasks[i];\n        const includeTask = await this.askYesNo(`Include: \"${task.title}\"?`);\n        \n        if (includeTask) {\n          this.plannedTasks.push(task);\n        }\n      }\n    }\n    \n    // Allow custom tasks\n    const addCustom = await this.askYesNo('\\nWould you like to add custom tasks?');\n    \n    if (addCustom) {\n      await this.addCustomTasks();\n    }\n    \n    // Prioritize tasks\n    await this.prioritizeTasks();\n    \n    // Show final task list\n    this.showTaskPlan();\n  }\n  \n  generateTaskSuggestions() {\n    const suggestions = [];\n    const project = this.currentProject;\n    \n    // Quality-based suggestions\n    project.quality.issues.forEach(issue => {\n      switch (issue.type) {\n        case 'missing_readme':\n          suggestions.push({\n            title: 'Create comprehensive README documentation',\n            description: 'Add project overview, setup instructions, and usage examples',\n            category: 'documentation',\n            priority: 'high',\n            estimatedHours: 2,\n            agentRole: 'technical_writer'\n          });\n          break;\n          \n        case 'low_test_coverage':\n          suggestions.push({\n            title: 'Improve test coverage',\n            description: `Increase test coverage from ${issue.coverage?.toFixed(1)}% to 80%+`,\n            category: 'testing',\n            priority: 'high',\n            estimatedHours: 8,\n            agentRole: 'qa_engineer'\n          });\n          break;\n          \n        case 'large_files':\n          suggestions.push({\n            title: 'Refactor large files',\n            description: `Break down ${issue.count} large files into smaller modules`,\n            category: 'refactoring',\n            priority: 'medium',\n            estimatedHours: 6,\n            agentRole: 'backend_developer'\n          });\n          break;\n      }\n    });\n    \n    // Framework-based suggestions\n    project.techStack.frameworks.forEach(framework => {\n      if (framework.name === 'Express.js' && !project.dependencies.direct.find(d => d.name === 'helmet')) {\n        suggestions.push({\n          title: 'Add security middleware',\n          description: 'Implement security headers and protection (helmet, cors, rate limiting)',\n          category: 'security',\n          priority: 'high',\n          estimatedHours: 3,\n          agentRole: 'security_engineer'\n        });\n      }\n      \n      if (framework.name === 'React' && !project.dependencies.direct.find(d => d.name.includes('test'))) {\n        suggestions.push({\n          title: 'Setup React testing framework',\n          description: 'Configure Jest and React Testing Library for component testing',\n          category: 'testing',\n          priority: 'medium',\n          estimatedHours: 4,\n          agentRole: 'frontend_developer'\n        });\n      }\n    });\n    \n    // Architecture-based suggestions\n    if (project.patterns.architectureStyle === 'monolithic' && project.metadata.totalFiles > 100) {\n      suggestions.push({\n        title: 'Modularize architecture',\n        description: 'Break monolithic structure into feature-based modules',\n        category: 'architecture',\n        priority: 'medium',\n        estimatedHours: 12,\n        agentRole: 'solution_architect'\n      });\n    }\n    \n    // Git-based suggestions\n    if (!project.gitHistory.hasGit) {\n      suggestions.push({\n        title: 'Initialize Git repository',\n        description: 'Setup version control with proper gitignore and initial commit',\n        category: 'setup',\n        priority: 'high',\n        estimatedHours: 1,\n        agentRole: 'devops_engineer'\n      });\n    }\n    \n    // CI/CD suggestions\n    if (!project.structure.files.find(f => f.name.includes('yml') || f.name.includes('yaml'))) {\n      suggestions.push({\n        title: 'Setup CI/CD pipeline',\n        description: 'Configure automated testing and deployment pipeline',\n        category: 'devops',\n        priority: 'medium',\n        estimatedHours: 6,\n        agentRole: 'devops_engineer'\n      });\n    }\n    \n    return suggestions;\n  }\n  \n  async addCustomTasks() {\n    console.log(chalk.yellow('\\n➕ Add your custom tasks:'));\n    \n    let addingTasks = true;\n    \n    while (addingTasks) {\n      const title = await this.askQuestion('Task title:');\n      if (!title.trim()) break;\n      \n      const description = await this.askQuestion('Task description:');\n      const category = await this.askQuestion('Category (feature/bugfix/improvement/documentation/etc.):');\n      const estimatedHours = await this.askQuestion('Estimated hours (number):');\n      \n      const customTask = {\n        title: title.trim(),\n        description: description.trim(),\n        category: category.trim() || 'custom',\n        priority: 'medium',\n        estimatedHours: parseInt(estimatedHours) || 4,\n        agentRole: 'backend_developer', // Default, will be refined later\n        custom: true\n      };\n      \n      this.plannedTasks.push(customTask);\n      \n      addingTasks = await this.askYesNo('Add another custom task?');\n    }\n  }\n  \n  async prioritizeTasks() {\n    if (this.plannedTasks.length <= 1) return;\n    \n    console.log(chalk.cyan('\\n🏆 Let\\'s prioritize these tasks...'));\n    \n    for (let i = 0; i < this.plannedTasks.length; i++) {\n      const task = this.plannedTasks[i];\n      console.log(`\\n${i + 1}. ${chalk.yellow(task.title)}`);\n      console.log(`   ${chalk.gray(task.description)}`);\n      \n      const priority = await this.askQuestion(\n        'Priority (high/medium/low) [current: ' + task.priority + ']:'\n      );\n      \n      if (priority.trim() && ['high', 'medium', 'low'].includes(priority.trim().toLowerCase())) {\n        task.priority = priority.trim().toLowerCase();\n      }\n    }\n    \n    // Sort by priority\n    const priorityOrder = { high: 1, medium: 2, low: 3 };\n    this.plannedTasks.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n  }\n  \n  showTaskPlan() {\n    console.log(chalk.green('\\n📋 Final Task Plan:'));\n    \n    const tasksByPriority = {\n      high: this.plannedTasks.filter(t => t.priority === 'high'),\n      medium: this.plannedTasks.filter(t => t.priority === 'medium'),\n      low: this.plannedTasks.filter(t => t.priority === 'low')\n    };\n    \n    Object.entries(tasksByPriority).forEach(([priority, tasks]) => {\n      if (tasks.length > 0) {\n        console.log(`\\n${chalk.bold(priority.toUpperCase())} PRIORITY:`);\n        tasks.forEach((task, index) => {\n          const priorityIcon = priority === 'high' ? '🔴' : priority === 'medium' ? '🟡' : '🟢';\n          console.log(`  ${priorityIcon} ${task.title} ${chalk.gray('(' + task.estimatedHours + 'h)')}`);\n        });\n      }\n    });\n    \n    const totalHours = this.plannedTasks.reduce((sum, task) => sum + task.estimatedHours, 0);\n    console.log(chalk.cyan(`\\n⏱️  Total estimated time: ${totalHours} hours`));\n  }\n  \n  async setCompletionCriteria() {\n    console.log(chalk.cyan('\\n🎯 Finally, let\\'s define what \"done\" looks like...'));\n    \n    const criteria = [];\n    \n    // Suggest basic criteria\n    const basicCriteria = [\n      'All planned tasks completed',\n      'Tests passing',\n      'Documentation updated',\n      'Code review completed'\n    ];\n    \n    console.log(chalk.yellow('\\n📝 Suggested completion criteria:'));\n    basicCriteria.forEach((criterion, index) => {\n      console.log(`  ${index + 1}. ${criterion}`);\n    });\n    \n    const useBasic = await this.askYesNo('\\nInclude these basic criteria?');\n    \n    if (useBasic) {\n      criteria.push(...basicCriteria.map(c => ({ description: c, type: 'basic' })));\n    }\n    \n    // Custom criteria\n    const addCustom = await this.askYesNo('Add custom completion criteria?');\n    \n    if (addCustom) {\n      console.log(chalk.yellow('\\nAdd your custom criteria (press Enter on empty line to finish):'));\n      \n      let addingCriteria = true;\n      while (addingCriteria) {\n        const criterion = await this.askQuestion('Completion criterion:');\n        if (!criterion.trim()) break;\n        \n        criteria.push({ description: criterion.trim(), type: 'custom' });\n        \n        addingCriteria = await this.askYesNo('Add another criterion?');\n      }\n    }\n    \n    this.completionCriteria = criteria;\n    \n    // Show final criteria\n    console.log(chalk.green('\\n✅ Project Completion Criteria:'));\n    criteria.forEach((criterion, index) => {\n      console.log(`  ${index + 1}. ${chalk.cyan(criterion.description)}`);\n    });\n  }\n  \n  async generateFinalPlan() {\n    const totalHours = this.plannedTasks.reduce((sum, task) => sum + task.estimatedHours, 0);\n    const highPriorityTasks = this.plannedTasks.filter(t => t.priority === 'high').length;\n    \n    const projectPlan = {\n      id: `plan_${Date.now()}`,\n      projectId: this.currentProject.id,\n      projectPath: this.currentProject.path,\n      createdAt: new Date().toISOString(),\n      \n      analysis: {\n        summary: {\n          files: this.currentProject.metadata.totalFiles,\n          linesOfCode: this.currentProject.metadata.totalLines,\n          languages: this.currentProject.metadata.languages,\n          frameworks: this.currentProject.metadata.frameworks,\n          qualityScore: this.currentProject.quality.score\n        },\n        issues: this.currentProject.quality.issues,\n        techStack: this.currentProject.techStack\n      },\n      \n      goals: this.currentProject.goals,\n      \n      tasks: this.plannedTasks,\n      \n      completionCriteria: this.completionCriteria,\n      \n      estimates: {\n        totalHours,\n        totalTasks: this.plannedTasks.length,\n        highPriorityTasks,\n        estimatedDays: Math.ceil(totalHours / 8), // 8 hours per day\n        complexity: totalHours > 40 ? 'high' : totalHours > 20 ? 'medium' : 'low'\n      },\n      \n      agentAssignments: this.generateAgentAssignments(),\n      \n      timeline: this.generateTimeline()\n    };\n    \n    return projectPlan;\n  }\n  \n  generateAgentAssignments() {\n    const assignments = {};\n    \n    this.plannedTasks.forEach(task => {\n      const role = task.agentRole;\n      if (!assignments[role]) {\n        assignments[role] = [];\n      }\n      assignments[role].push({\n        taskTitle: task.title,\n        estimatedHours: task.estimatedHours,\n        priority: task.priority\n      });\n    });\n    \n    return assignments;\n  }\n  \n  generateTimeline() {\n    const timeline = {\n      phases: [],\n      milestones: []\n    };\n    \n    // Group tasks by priority for phases\n    const highPriorityTasks = this.plannedTasks.filter(t => t.priority === 'high');\n    const mediumPriorityTasks = this.plannedTasks.filter(t => t.priority === 'medium');\n    const lowPriorityTasks = this.plannedTasks.filter(t => t.priority === 'low');\n    \n    if (highPriorityTasks.length > 0) {\n      timeline.phases.push({\n        name: 'Phase 1: Critical Tasks',\n        tasks: highPriorityTasks.map(t => t.title),\n        estimatedDays: Math.ceil(highPriorityTasks.reduce((sum, t) => sum + t.estimatedHours, 0) / 8)\n      });\n    }\n    \n    if (mediumPriorityTasks.length > 0) {\n      timeline.phases.push({\n        name: 'Phase 2: Important Tasks',\n        tasks: mediumPriorityTasks.map(t => t.title),\n        estimatedDays: Math.ceil(mediumPriorityTasks.reduce((sum, t) => sum + t.estimatedHours, 0) / 8)\n      });\n    }\n    \n    if (lowPriorityTasks.length > 0) {\n      timeline.phases.push({\n        name: 'Phase 3: Nice-to-Have Tasks',\n        tasks: lowPriorityTasks.map(t => t.title),\n        estimatedDays: Math.ceil(lowPriorityTasks.reduce((sum, t) => sum + t.estimatedHours, 0) / 8)\n      });\n    }\n    \n    return timeline;\n  }\n  \n  async storePlanAndStart(projectPlan) {\n    // Store the project plan\n    const planKey = `project_plan:${projectPlan.id}`;\n    \n    await this.taskManager.redis.hSet(planKey, {\n      id: projectPlan.id,\n      projectId: projectPlan.projectId,\n      projectPath: projectPlan.projectPath,\n      createdAt: projectPlan.createdAt,\n      data: JSON.stringify(projectPlan)\n    });\n    \n    // Add to plans index\n    await this.taskManager.redis.sAdd('project_plans', projectPlan.id);\n    \n    // Show final summary\n    this.showFinalSummary(projectPlan);\n    \n    // Ask if user wants to start execution\n    const startNow = await this.askYesNo('\\nWould you like to start the autonomous execution now?');\n    \n    if (startNow) {\n      await this.startExecution(projectPlan);\n    } else {\n      console.log(chalk.yellow('\\n📋 Project plan saved. You can start execution later with:'));\n      console.log(chalk.cyan(`   debo execute ${projectPlan.id}`));\n    }\n  }\n  \n  showFinalSummary(projectPlan) {\n    const summaryBox = boxen(\n      `Project: ${chalk.yellow(this.currentProject.name)}\\n` +\n      `Tasks: ${chalk.cyan(projectPlan.estimates.totalTasks)}\\n` +\n      `Estimated Time: ${chalk.green(projectPlan.estimates.totalHours + ' hours')}\\n` +\n      `Complexity: ${chalk.magenta(projectPlan.estimates.complexity)}\\n` +\n      `Agents Required: ${chalk.blue(Object.keys(projectPlan.agentAssignments).length)}\\n` +\n      `Timeline: ${chalk.gray(projectPlan.estimates.estimatedDays + ' days')}`,\n      {\n        title: chalk.bold('🎯 Project Plan Summary'),\n        padding: 1,\n        borderColor: 'green',\n        borderStyle: 'double'\n      }\n    );\n    \n    console.log('\\n' + summaryBox);\n  }\n  \n  async startExecution(projectPlan) {\n    console.log(chalk.green('\\n🚀 Starting autonomous execution...'));\n    \n    // Create tasks in the agent queue\n    for (const task of projectPlan.tasks) {\n      const agentTask = {\n        projectId: projectPlan.projectId,\n        type: task.category,\n        requiredRole: task.agentRole,\n        title: task.title,\n        description: task.description,\n        priority: task.priority,\n        estimatedHours: task.estimatedHours,\n        planId: projectPlan.id\n      };\n      \n      await this.taskManager.agentQueue.enqueueTask(agentTask);\n    }\n    \n    console.log(chalk.green(`✅ ${projectPlan.tasks.length} tasks queued for execution`));\n    console.log(chalk.cyan('\\n🔍 Use \"debo dashboard\" to monitor progress in real-time'));\n  }\n  \n  async askQuestion(question) {\n    return new Promise((resolve) => {\n      this.rl.question(chalk.cyan(`❓ ${question} `), (answer) => {\n        resolve(answer);\n      });\n    });\n  }\n  \n  async askYesNo(question) {\n    const answer = await this.askQuestion(`${question} (y/n)`);\n    return answer.toLowerCase().startsWith('y');\n  }\n  \n  cleanup() {\n    this.rl.close();\n  }\n}\n\nexport default ProjectPlanner;\n